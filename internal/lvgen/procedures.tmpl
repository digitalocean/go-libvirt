// Copyright 2018 The go-libvirt Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Code generated by internal/lvgen/generate.go. DO NOT EDIT.
//
// To regenerate, run 'go generate' in internal/lvgen.
//

package libvirt

import (
	"bytes"
	"fmt"
	"io"
	"reflect"

	"github.com/digitalocean/go-libvirt/internal/constants"
	"github.com/digitalocean/go-libvirt/internal/go-xdr/xdr2"
)

const (
	VirUUIDBuflen = 16
)

type typedParamDecoder struct {}

// Decode decodes a TypedParam. These are part of the libvirt spec, and not xdr
// proper. TypedParams contain a name, which is called Field for some reason,
// and a Value, which itself has a "discriminant" - an integer enum encoding the
// actual type, and a value, the length of which varies based on the actual
// type.
func (tpd typedParamDecoder) Decode(d *xdr.Decoder, v reflect.Value) (int, error) {
	// Get the name of the typed param first
	name, n, err := d.DecodeString()
	if err != nil {
		return n, err
	}
	val, n2, err := tpd.decodeTypedParamValue(d)
	n += n2
	if err != nil {
		return n, err
	}
	tp := &TypedParam{Field: name, Value: *val}
	v.Set(reflect.ValueOf(*tp))

	return n, nil
}

// decodeTypedParamValue decodes the Value part of a TypedParam.
func (typedParamDecoder) decodeTypedParamValue(d *xdr.Decoder) (*TypedParamValue, int, error) {
	// All TypedParamValues begin with a uint32 discriminant that tells us what
	// type they are.
	discriminant, n, err := d.DecodeUint()
	if err != nil {
		return nil, n, err
	}
	var n2 int
	var tpv *TypedParamValue
	switch discriminant {
	case 1:
		var val int32
		n2, err = d.Decode(&val)
		tpv = &TypedParamValue{D: discriminant, I: val}
	case 2:
		var val uint32
		n2, err = d.Decode(&val)
		tpv = &TypedParamValue{D: discriminant, I: val}
	case 3:
		var val int64
		n2, err = d.Decode(&val)
		tpv = &TypedParamValue{D: discriminant, I: val}
	case 4:
		var val uint64
		n2, err = d.Decode(&val)
		tpv = &TypedParamValue{D: discriminant, I: val}
	case 5:
		var val float64
		n2, err = d.Decode(&val)
		tpv = &TypedParamValue{D: discriminant, I: val}
	case 6:
		var val int32
		n2, err = d.Decode(&val)
		tpv = &TypedParamValue{D: discriminant, I: val}
	case 7:
		var val string
		n2, err = d.Decode(&val)
		tpv = &TypedParamValue{D: discriminant, I: val}

	default:
		err = fmt.Errorf("invalid parameter type %v", discriminant)
	}
	n += n2

	return tpv, n, err
}

//
// Typedefs:
//
{{range .Typedefs}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} {{.Type}}
{{end}}
//
// Enums:
//
{{range .Enums}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} {{.Type}}
{{end}}
//
// Structs:
//
{{range .Structs}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} struct {
{{range .Members}}	{{.Name}} {{.Type}}
{{end -}}
}

{{end}}

{{range .Unions}}// {{.Name}} is a discriminated union.
type {{.Name}} struct {
	D uint32
	I interface{}
{{end -}}
}
{{range .Unions}}{{$uname := .Name}}{{range .Cases}}{{$casetype := printf "%v%v" $uname .CaseName}}
// New{{$casetype}} creates a discriminated union value satisfying
// the {{$uname}} interface.
func New{{$casetype}}(v {{.Type}}) *{{$uname}} {
	return &{{$uname}}{D: {{.DiscriminantVal}}, I: v}
}
{{end}}
{{- end}}
{{range $proc := .Procs}}
// {{.Name}} is the go wrapper for {{.LVName}}.
func (l *Libvirt) {{.Name}}(
  {{- range $ix, $arg := .Args}}
    {{- if (eq $ix $proc.WriteStreamIdx)}}{{if $ix}}, {{end}}outStream io.Reader{{end}}
    {{- if (eq $ix $proc.ReadStreamIdx)}}{{if $ix}}, {{end}}inStream io.Writer{{end}}
    {{- if $ix}}, {{end}}{{.Name}} {{.Type}}
  {{- end -}}
) ({{range .Ret}}r{{.Name}} {{.Type}}, {{end}}err error) {
	var buf []byte
{{if .ArgsStruct}}
	args := {{.ArgsStruct}} {
{{range .Args}}		{{.Name}}: {{.Name}},
{{end}}	}

	buf, err = encode(&args)
	if err != nil {
		return
	}
{{end}}
{{if .RetStruct}}	var r response{{end}}
	{{if .RetStruct}}r{{else}}_{{end}}, err = l.requestStream({{.Num}}, constants.Program, buf,
    {{- if (ne .WriteStreamIdx -1)}} outStream,{{else}} nil,{{end}}
    {{- if (ne .ReadStreamIdx -1)}} inStream{{else}} nil{{end -}}
    )
	if err != nil {
		return
	}
{{if .RetStruct}}
	// Return value unmarshaling
	tpd := typedParamDecoder{}
	ct := map[string]xdr.TypeDecoder{"libvirt.TypedParam": tpd}
	rdr := bytes.NewReader(r.Payload)
	dec := xdr.NewDecoderCustomTypes(rdr, 0, ct)
{{range .Ret}}	// {{.Name}}: {{.Type}}
	_, err = dec.Decode(&r{{.Name}})
	if err != nil {
		return
	}
{{end}}{{end}}
	return
}
{{end}}
