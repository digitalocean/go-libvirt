// Copyright 2017 The go-libvirt Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Code generated by internal/lvgen/generate.go. DO NOT EDIT.
//
// To regenerate, run 'go generate' in internal/lvgen.
//

package libvirt

import (
	"bytes"
	"fmt"

	"github.com/davecgh/go-xdr/xdr2"
	"github.com/digitalocean/go-libvirt/internal/constants"
)

const (
	VirUUIDBuflen = 16
)

//
// Typedefs:
//
{{range .Typedefs}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} {{.Type}}
{{end}}
//
// Enums:
//
{{range .Enums}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} {{.Type}}
{{end}}
//
// Structs:
//
{{range .Structs}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} struct {
{{range .Members}}	{{.Name}} {{.Type}}
{{end -}}
}

{{end}}
{{range .Unions}}// {{.Name}} is a discriminated union.
type {{.Name}} interface {
	Get() interface{}
{{end -}}
}
{{range .Unions}}{{$uname := .Name}}{{range .Cases}}{{$casetype := printf "%v%v" $uname .CaseName}}
// {{$casetype}} is one of the possible values of the {{$uname}} union.
type {{$casetype}} struct {
	DVal uint32
	{{.Name}} {{.Type}}
}
// New{{$casetype}} creates a discriminated union value satisfying
// the {{$uname}} interface.
func New{{$casetype}}(v {{.Type}}) *{{$casetype}} {
	return &{{$casetype}}{DVal: {{.DiscriminantVal}}, {{.Name}}: v}
}
func decode{{$casetype}}(dec *xdr.Decoder) (*{{$casetype}}, error) {
	var v {{.Type}}
	_, err := dec.Decode(&v)
	if err != nil {
		return nil, err
	}
	return New{{$casetype}}(v), nil
}
// Get satisfies the {{$uname}} interface.
func (c *{{$casetype}}) Get() interface{} { return c.{{.Name}} }
{{end}}
func decode{{.Name}}(dec *xdr.Decoder) ({{.Name}}, error) {
	discriminant, _, err := dec.DecodeInt()
	if err != nil {
		return nil, err
	}
	var caseval {{.Name}}
	switch discriminant {
{{range .Cases}}{{$casetype := printf "%v%v" $uname .CaseName}}	case {{.DiscriminantVal}}:
		caseval, err = decode{{$casetype}}(dec)
{{end}}
	default:
		err = fmt.Errorf("invalid parameter type %v", discriminant)
	}

	return caseval, err
}
{{- end}}

// TODO: Generate these.
func decodeTypedParam(dec *xdr.Decoder) (*TypedParam, error) {
	name, _, err := dec.DecodeString()
	if err != nil {
		return nil, err
	}
	val, err := decodeTypedParamValue(dec)
	return &TypedParam{name, val}, nil
}

func decodeTypedParams(dec *xdr.Decoder) ([]TypedParam, error) {
	count, _, err := dec.DecodeInt()
	if err != nil {
		return nil, err
	}
	params := make([]TypedParam, count)
	for ix := int32(0); ix < count; ix++ {
		p, err := decodeTypedParam(dec)
		if err != nil {
			return nil, err
		}
		params[ix] = *p
	}

	return params, nil
}

{{range .Procs}}
// {{.Name}} is the go wrapper for {{.LVName}}.
func (l *Libvirt) {{.Name}}({{range $ix, $arg := .Args}}{{if $ix}}, {{end}}{{.Name}} {{.Type}}{{end}}) ({{range .Ret}}r{{.Name}} {{.Type}}, {{end}}err error) {
	var buf bytes.Buffer
{{if .ArgsStruct}}
	args := {{.ArgsStruct}} {
{{range .Args}}		{{.Name}}: {{.Name}},
{{end}}	}

	buf, err = encode(&args)
	if err != nil {
		return
	}
{{end}}
	var resp <-chan response
	resp, err = l.request({{.Num}}, constants.Program, &buf)
	if err != nil {
		return
	}

	r := <-resp
	if r.Status != StatusOK {
		err = decodeError(r.Payload)
		return
	}
{{if .RetStruct}}
	// Return value unmarshaling
	rdr := bytes.NewReader(r.Payload)
	dec := xdr.NewDecoder(rdr)
{{range .Ret}}	// {{.Name}}: {{.Type}}
{{if eq .Type "[]TypedParam"}}	r{{.Name}}, err = decodeTypedParams(dec)
	if err != nil {
		fmt.Println("error decoding typedparams")
		return
	}
{{else}}	_, err = dec.Decode(&r{{.Name}})
	if err != nil {
		return
	}
{{end}}{{end}}{{end}}
	return
}
{{end}}
