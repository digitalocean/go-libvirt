// Copyright 2018 The go-libvirt Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Code generated by internal/lvgen/generate.go. DO NOT EDIT.
//
// To regenerate, run 'go generate' in internal/lvgen.
//

package libvirt

import (
	"bytes"
	"io"

	"github.com/digitalocean/go-libvirt/internal/constants"
	"github.com/digitalocean/go-libvirt/internal/go-xdr/xdr2"
)

// References to prevent "imported and not used" errors.
var (
	_ = bytes.Buffer{}
	_ = io.Copy
	_ = constants.Program
	_ = xdr.Unmarshal
)

//
// Typedefs:
//
{{range .Typedefs}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} {{.Type}}
{{end}}
//
// Enums:
//
{{range .Enums}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} {{.Type}}
{{end}}
//
// Structs:
//
{{range .Structs}}// {{.Name}} is libvirt's {{.LVName}}
type {{.Name}} struct {
{{range .Members}}	{{.Name}} {{.Type}}
{{end -}}
}

{{end}}
{{range .Unions}}// {{.Name}} is a discriminated union.
type {{.Name}} struct {
	D uint32
	I interface{}
}
{{end -}}
{{range .Unions}}{{$uname := .Name}}{{range .Cases}}{{$casetype := printf "%v%v" $uname .CaseName}}
// New{{$casetype}} creates a discriminated union value satisfying
// the {{$uname}} interface.
func New{{$casetype}}(v {{.Type}}) *{{$uname}} {
	return &{{$uname}}{D: {{.DiscriminantVal}}, I: v}
}
{{end}}
{{- end}}
{{range $proc := .Procs}}
// {{.Name}} is the go wrapper for {{.LVName}}.
func (l *Libvirt) {{.Name}}(
  {{- range $ix, $arg := .Args}}
    {{- if (eq $ix $proc.WriteStreamIdx)}}{{if $ix}}, {{end}}outStream io.Reader{{end}}
    {{- if (eq $ix $proc.ReadStreamIdx)}}{{if $ix}}, {{end}}inStream io.Writer{{end}}
    {{- if $ix}}, {{end}}{{.Name}} {{.Type}}
  {{- end -}}
) ({{range .Ret}}r{{.Name}} {{.Type}}, {{end}}err error) {
	var buf []byte
{{if .ArgsStruct}}
	args := {{.ArgsStruct}} {
{{range .Args}}		{{.Name}}: {{.Name}},
{{end}}	}

	buf, err = encode(&args)
	if err != nil {
		return
	}
{{end}}
{{if .RetStruct}}	var r response{{end}}
	{{if .RetStruct}}r{{else}}_{{end}}, err = l.requestStream({{.Num}}, constants.{{.Program}}Program, buf,
    {{- if (ne .WriteStreamIdx -1)}} outStream,{{else}} nil,{{end}}
    {{- if (ne .ReadStreamIdx -1)}} inStream{{else}} nil{{end -}}
    )
	if err != nil {
		return
	}
{{if .RetStruct}}
	// Return value unmarshaling
	tpd := typedParamDecoder{}
	ct := map[string]xdr.TypeDecoder{"libvirt.TypedParam": tpd}
	rdr := bytes.NewReader(r.Payload)
	dec := xdr.NewDecoderCustomTypes(rdr, 0, ct)
{{range .Ret}}	// {{.Name}}: {{.Type}}
	_, err = dec.Decode(&r{{.Name}})
	if err != nil {
		return
	}
{{end}}{{end}}
	return
}
{{end}}
